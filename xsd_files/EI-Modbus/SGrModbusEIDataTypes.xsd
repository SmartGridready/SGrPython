<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- edited with Eclipse Modeling Tools - 2020-10 by Christoph Broennimann 
	(IBT Ing. Buero Broennimann Thun) --><!-- Copyright (c) Verein SmartGridready, Switzerland Version 0.2.2 2022-8-22 
	All Rights Reserved. Source: https://www.SmartGridready.ch/ --><schema xmlns="http://www.w3.org/2001/XMLSchema" xmlns:sgr="http://www.smartgridready.com/ns/V0/" attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://www.smartgridready.com/ns/V0/" version="0.2.2">
  <!-- ************************************** -->
  <!-- IEC 61850-80-5 inherited data types -->
  <!-- ************************************** -->
  <!-- add e new external Interface definition for any IEC application extension 
		enumerations and data type conversion will need additional data type defintions 
		not directly visible in the modbus.xsd files of 80-5 -->
  <!-- ************************************** -->
  <!-- Modbus Communication Section: TCP based -->
  <!-- ************************************** -->
  <include schemaLocation="../Generic/SGrSerialIntCapability.xsd"/>
  <complexType name="tP_IPModbus">
    <annotation>
      <documentation>Modbus IP address:Specific P elements for Modbus over
				IP protocol. This definition is partially inherited from
				61850-80-5's tPTypeModbusIPEnum typedef but reduced to a single
				interface (not redundant adresses RG1 and RG2) and information layer
				definitions
			</documentation>
    </annotation>
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="port" type="sgr:tIPportNrType"/>
      <element maxOccurs="1" minOccurs="1" name="address" type="sgr:ipADDRType"/>
      <element maxOccurs="1" minOccurs="1" name="slaveID" type="sgr:tSlaveIDType"/>
    </sequence>
  </complexType>
  <simpleType name="tIPportNrType">
    <annotation>
      <documentation>
  			Modbus Port number, default use is Port 502
  		</documentation>
    </annotation>
    <restriction base="unsignedInt">
  	</restriction>
  </simpleType>
  <complexType name="ipADDRType">
    <annotation>
      <documentation>Modbus device address</documentation>
    </annotation>
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="ipV4n1">
        <simpleType>
          <restriction base="positiveInteger">
            <minInclusive value="1"/>
            <maxInclusive value="255"/>
          </restriction>
        </simpleType>
      </element>
      <element maxOccurs="1" minOccurs="1" name="ipV4n2">
        <simpleType>
          <restriction base="positiveInteger">
            <minInclusive value="1"/>
            <maxInclusive value="255"/>
          </restriction>
        </simpleType>
      </element>
      <element maxOccurs="1" minOccurs="1" name="ipV4n3">
        <simpleType>
          <restriction base="positiveInteger">
            <minInclusive value="1"/>
            <maxInclusive value="255"/>
          </restriction>
        </simpleType>
      </element>
      <element maxOccurs="1" minOccurs="1" name="ipV4n4">
        <simpleType>
          <restriction base="positiveInteger">
            <minInclusive value="1"/>
            <maxInclusive value="255"/>
          </restriction>
        </simpleType>
      </element>
    </sequence>
  </complexType>
  <simpleType name="tSlaveIDType">
    <annotation>
      <documentation>Modbus Slave Address</documentation>
    </annotation>
    <restriction base="unsignedShort">
  	</restriction>
  </simpleType>
  <!-- ****************************************** -->
  <!-- Modbus Conversion function section -->
  <!-- ****************************************** -->
  <!-- Conversion functions -->
  <simpleType name="tEnumConversionFct">
    <annotation>
      <documentation> Modbus conversion functions are used to apply
				different transformations to data between Modbus device and IEC61850
				devices. There are different kind of conversions, depending on
				operation to apply: - Bit conversion: ChangeDWordOrder,
				ChangeWordOrder, ChangeByteOrder, ChangeBitOrder
			</documentation>
    </annotation>
    <restriction base="string">
      <enumeration value="BigEndian"/>
      <enumeration value="ChangeDWordOrder"/>
      <enumeration value="ChangeWordOrder"/>
      <enumeration value="ChangeByteOrder"/>
      <enumeration value="ChangeBitOrder"/>
    </restriction>
  </simpleType>
  <!-- **************************** -->
  <!-- Modbus Address section -->
  <!-- **************************** -->
  <simpleType name="tEnumObjectType">
    <annotation>
      <documentation>Type of the Modbus Data. For slave-role, definition of
				the Object Type of the data: Discretes Input: Single bit, Read-Only;
				Coils: Single bit, Read-Write; Input Registers: 16-bit word,
				Read-Only; Holding Registers: 16-bit word, Read-Write.
			</documentation>
    </annotation>
    <restriction base="string">
      <enumeration value="Coil"/>
      <enumeration value="DiscreteInput"/>
      <enumeration value="InputRegister"/>
      <enumeration value="HoldRegister"/>
    </restriction>
  </simpleType>
  <simpleType name="tBitRank">
    <annotation>
      <documentation>Rank of a bit data represented with a register. The
				bit rank used to define a bit address (bitAddress = addr x 16 +
				bitRank
			</documentation>
    </annotation>
    <restriction base="unsignedByte">
      <minInclusive value="0"/>
      <maxInclusive value="15"/>
    </restriction>
  </simpleType>
  <complexType name="tSGrModbus_RegisterRef">
    <annotation>
      <documentation>2-bytes-word address: could be a register address (to
				address a modbus register - inputRegister or holdRegister) or a part
				of a bit address, see bitRank definition
			</documentation>
    </annotation>
    <attribute name="addr" type="nonNegativeInteger" use="required">
      <annotation>
        <documentation>2-bytes-word address: could be a register address (to
					address a modbus register - inputRegister or holdRegister) or a
					part of a bit address, see bitRank definition
				</documentation>
      </annotation>
    </attribute>
    <attribute name="bitRank" type="sgr:tBitRank" use="optional">
      <annotation>
        <documentation>The bit rank used to define a bit address (bitAddress
					= addr x 16 + bitRank)
				</documentation>
      </annotation>
    </attribute>
    <attribute name="registerType" type="sgr:tEnumObjectType" use="required">
      <annotation>
        <documentation>For slave-role, definition of the Object Type of the
					data: Discretes Input: Single bit, Read-Only; Coils: Single bit,
					Read-Write; Input Registers: 16-bit word, Read-Only; Holding
					Registers: 16-bit word, Read-Write.
				</documentation>
      </annotation>
    </attribute>
  </complexType>
  <simpleType name="tEnumExceptionCodeType">
    <annotation>
      <documentation>Type of the Modbus Exceptions sent by Slave (Server)
				responses.
			</documentation>
    </annotation>
    <restriction base="string">
      <enumeration value="IllegalFunction">
        <annotation>
          <documentation>"1: Illegal Function Function code received in the
						query is not recognized or allowed by slave"
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="IllegalAddress">
        <annotation>
          <documentation>2: Illegal Data Address Data address of some or all
						the required entities are not allowed or do not exist in slave
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="IllegalDataValue">
        <annotation>
          <documentation>3: Illegal Data Value Value is not accepted by slave
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="SlaveFailure">
        <annotation>
          <documentation>4: Slave (Server) Device Failure Unrecoverable error
						occurred while slave was attempting to perform requested action
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="ACK">
        <annotation>
          <documentation>5: Acknowledge Slave has accepted request and is
						processing it, but a long duration of time is required. This
						response is returned to prevent a timeout error from occurring in
						the master. Master can next issue a Poll Program Complete message
						to determine whether processing is completed
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="SlaveBusy">
        <annotation>
          <documentation>6: Slave (Server) Device Busy Slave is engaged in
						processing a long-duration command. Master should retry later
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="NACK">
        <annotation>
          <documentation>7: Negative Acknowledge Slave (Server) cannot
						perform the programming functions. Master should request
						diagnostic or error information from slave
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="MemoryParityErr">
        <annotation>
          <documentation>8: Memory Parity Error Slave (Server) detected a
						parity error in memory. Master can retry the request, but service
						may be required on the slave device
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="GtwyPathErr">
        <annotation>
          <documentation>10: Gateway Path Unavailable Specialized for Modbus
						gateways. Indicates a misconfigured gateway
					</documentation>
        </annotation>
      </enumeration>
      <enumeration value="GtwyTargetErr">
        <annotation>
          <documentation>11: Gateway Target Device Failed to Respond
						Specialized for Modbus gateways. Sent when slave fails to respond
					</documentation>
        </annotation>
      </enumeration>
    </restriction>
  </simpleType>
  <!-- actual serial interface configuration -->
  <complexType name="tP_RTUModbus">
    <sequence>
      <element maxOccurs="1" minOccurs="1" name="slaveAddr" type="sgr:tSlaveIDType"/>
      <element maxOccurs="1" minOccurs="1" name="baudRateSelected" type="sgr:eBaudRateType"/>
      <element maxOccurs="1" minOccurs="1" name="byteLenSelected" type="sgr:eByteLenType"/>
      <element maxOccurs="1" minOccurs="1" name="paritySelected" type="sgr:eParityType"/>
      <element maxOccurs="1" minOccurs="1" name="stopBitLenSelected" type="sgr:eStopBitLenType"/>
      <element name="serialInterfaceCapability" type="sgr:SGrSerialInterfaceCapabilityType"/>
    </sequence>
  </complexType>
  <complexType name="timeSyncBlockNotificationType">
    <sequence>
      <element name="blockNumber" type="int"/>
      <element name="timeoutMs" type="int"/>
    </sequence>
  </complexType>
</schema>
